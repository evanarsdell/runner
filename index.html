<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Polished Endless Runner</title>
  <style>
    /* Reset & basic styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { overflow: hidden; font-family: sans-serif; background: #000; }
    canvas { display: block; }
    /* Overlay for start and game over screens */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.75);
      color: #fff;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }
    /* Progress meter at the top */
    #progressContainer {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 10px;
      background: rgba(255,255,255,0.2);
      border-radius: 5px;
      z-index: 5;
    }
    #progressBar {
      width: 0;
      height: 100%;
      background: lime;
      border-radius: 5px;
      transition: width 0.2s ease;
    }
    /* On-screen control buttons */
    .controlButton {
      position: fixed;
      bottom: 20px;
      padding: 12px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      z-index: 11;
      opacity: 0.9;
    }
    #jumpButton { left: 20px; background: #28a745; color: #fff; }
    #powerButton { right: 20px; background: #17a2b8; color: #fff; }
  </style>
</head>
<body>
  <!-- Overlay for start screen & game over -->
  <div id="overlay">
    <h1>Polished Runner</h1>
    <p>Tap anywhere or press any key to start</p>
  </div>
  <!-- Progress Meter -->
  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>
  <!-- On-screen control buttons -->
  <button id="jumpButton" class="controlButton" style="display:none;">Jump</button>
  <button id="powerButton" class="controlButton" style="display:none;">Shield</button>

  <script>
    // ==========================
    // Basic Setup & Global Vars
    // ==========================
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    const groundHeight = 50;
    const groundY = height - groundHeight;

    // Overlay & controls
    const overlay = document.getElementById("overlay");
    const jumpButton = document.getElementById("jumpButton");
    const powerButton = document.getElementById("powerButton");
    const progressBar = document.getElementById("progressBar");

    // Game state variables
    let gameStarted = false;
    let gameOver = false;
    let lastTime = 0;
    let score = 0;
    let coinsCollected = 0;
    let gameSpeed = 6;
    let level = 1;
    let levelThreshold = 100; // Increase level every 100 points
    let elapsedTime = 0;
    let highScore = localStorage.getItem("highScore") || 0;

    // ==========================
    // Audio Setup (JS Generated)
    // ==========================
    let audioCtx = null;
    function playTone(freq, duration, volume = 0.5) {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = freq;
      osc.type = "sine";
      gain.gain.value = volume;
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    function playJumpSound() { playTone(300, 0.1); }
    function playCoinSound() { playTone(600, 0.1); }
    function playCollisionSound() { playTone(100, 0.2); }
    function playPowerSound() { playTone(500, 0.15); }
    // Background chime loop (low volume)
    function startBackgroundChime() {
      setInterval(() => {
        playTone(200, 0.05, 0.2);
      }, 1500);
    }

    // ==========================
    // Theme & Background Setup
    // ==========================
    const themes = [
      {
        name: "day",
        gradient: ["#87CEEB", "#ffffff"],
        extras: "clouds"
      },
      {
        name: "sunset",
        gradient: ["#ff9a9e", "#fad0c4"],
        extras: "birds"
      },
      {
        name: "night",
        gradient: ["#0f2027", "#203a43"],
        extras: "stars"
      }
    ];
    const theme = themes[Math.floor(Math.random() * themes.length)];
    // Prepare parallax layers (two layers: far & near)
    let farObjects = [];
    let nearObjects = [];
    function initBackground() {
      farObjects = [];
      nearObjects = [];
      // Create a number of objects based on theme extras
      let count = 10;
      for (let i = 0; i < count; i++) {
        farObjects.push({
          x: Math.random() * width,
          y: Math.random() * (height * 0.5),
          size: 20 + Math.random() * 30,
          speed: 0.5 + Math.random() * 0.5
        });
      }
      count = 6;
      for (let i = 0; i < count; i++) {
        nearObjects.push({
          x: Math.random() * width,
          y: groundY - (10 + Math.random() * 40),
          width: 50 + Math.random() * 50,
          height: 20 + Math.random() * 30,
          speed: 1 + Math.random() * 1
        });
      }
    }
    initBackground();

    // ==========================
    // Player Setup (Animated Character)
    // ==========================
    const player = {
      x: 50,
      y: groundY - 60,
      width: 40,
      height: 60,
      dy: 0,
      jumpForce: -15,
      gravity: 0.8,
      jumpCount: 0,
      maxJumps: 2,
      animationTimer: 0,
      animationFrame: 0,
      shieldActive: false,
      shieldTimer: 0,
      shieldDuration: 3000 // 3 seconds
    };

    // ==========================
    // Game Objects: Obstacles, Coins, PowerUps
    // ==========================
    let obstacles = [];
    let coins = [];
    let powerUps = [];
    // Timers for spawning
    let obstacleTimer = 0;
    let coinTimer = 0;
    let powerTimer = 0;
    const obstacleInterval = 1500; // ms
    const coinInterval = 2000;
    const powerInterval = 7000;

    // Obstacle types: spike, boulder, bird
    function spawnObstacle() {
      const typeChance = Math.random();
      let obstacle = { x: width, type: "", speedModifier: 1 };
      if (typeChance < 0.4) { // Spike: triangle on ground
        obstacle.type = "spike";
        obstacle.width = 30;
        obstacle.height = 30;
        obstacle.y = groundY - obstacle.height;
      } else if (typeChance < 0.7) { // Boulder: rolling circle
        obstacle.type = "boulder";
        obstacle.radius = 15 + Math.random() * 10;
        obstacle.width = obstacle.radius * 2;
        obstacle.height = obstacle.radius * 2;
        obstacle.y = groundY - obstacle.height;
      } else { // Bird: flying enemy
        obstacle.type = "bird";
        obstacle.width = 40;
        obstacle.height = 30;
        obstacle.y = groundY - 150 - Math.random() * 50;
      }
      obstacles.push(obstacle);
    }
    function spawnCoin() {
      const coin = {
        x: width,
        y: groundY - 100 - Math.random() * 80,
        radius: 10
      };
      coins.push(coin);
    }
    function spawnPowerUp() {
      const power = {
        x: width,
        y: groundY - 120 - Math.random() * 50,
        size: 25,
        type: "shield"
      };
      powerUps.push(power);
    }

    // ==========================
    // Input Handling
    // ==========================
    function jump() {
      if (player.jumpCount < player.maxJumps) {
        player.dy = player.jumpForce;
        player.jumpCount++;
        playJumpSound();
      }
    }
    function activateShield() {
      // Activate shield only if not already active
      if (!player.shieldActive) {
        player.shieldActive = true;
        player.shieldTimer = player.shieldDuration;
        playPowerSound();
      }
    }
    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (!gameStarted) startGame();
      if (e.code === "Space" || e.code === "ArrowUp") {
        jump();
      }
      if (e.code === "KeyP") { // use power-up with "P" key
        activateShield();
      }
    });
    // Touch & click events
    document.addEventListener("touchstart", (e) => {
      if (!gameStarted) startGame();
      jump();
    });
    // On-screen buttons
    jumpButton.addEventListener("click", jump);
    powerButton.addEventListener("click", activateShield);

    // ==========================
    // Collision Detection Helper
    // ==========================
    function rectIntersect(a, b) {
      return (a.x < b.x + b.width &&
              a.x + a.width > b.x &&
              a.y < b.y + b.height &&
              a.y + a.height > b.y);
    }
    function circleRectIntersect(circle, rect) {
      // Find closest point to the circle within the rectangle
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
      let dx = circle.x - closestX;
      let dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (circle.radius * circle.radius);
    }

    // ==========================
    // Game Reset & Loop
    // ==========================
    function resetGame() {
      // Reset game state variables
      score = 0;
      coinsCollected = 0;
      gameSpeed = 6;
      level = 1;
      elapsedTime = 0;
      player.x = 50;
      player.y = groundY - player.height;
      player.dy = 0;
      player.jumpCount = 0;
      player.shieldActive = false;
      player.shieldTimer = 0;
      obstacles = [];
      coins = [];
      powerUps = [];
      obstacleTimer = 0;
      coinTimer = 0;
      powerTimer = 0;
      lastTime = performance.now();
      initBackground();
      overlay.style.display = "none";
      gameOver = false;
      gameStarted = true;
      startBackgroundChime();
      requestAnimationFrame(gameLoop);
    }
    function gameLoop(timestamp) {
      if (gameOver) return;
      let deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      elapsedTime += deltaTime;
      update(deltaTime);
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ==========================
    // Update Game State
    // ==========================
    function update(dt) {
      // Increase game speed gradually with score
      gameSpeed = 6 + score / 150;

      // Update progress bar toward next level threshold
      let progress = (score % levelThreshold) / levelThreshold;
      progressBar.style.width = (progress * 100) + "%";
      // Check level up
      if (score > level * levelThreshold) {
        level++;
        // Optionally show a level-up flash/effect (for brevity, we use an alert fade)
        ctx.fillStyle = "rgba(255,255,0,0.5)";
        ctx.fillRect(0,0,width,height);
      }

      // Update background parallax objects
      farObjects.forEach(obj => {
        obj.x -= obj.speed;
        if (obj.x < -obj.size) { obj.x = width + obj.size; obj.y = Math.random() * height * 0.5; }
      });
      nearObjects.forEach(obj => {
        obj.x -= obj.speed * (gameSpeed/6);
        if (obj.x < -obj.width) { obj.x = width; }
      });

      // Update player physics
      player.dy += player.gravity;
      player.y += player.dy;
      if (player.y + player.height >= groundY) {
        player.y = groundY - player.height;
        player.dy = 0;
        player.jumpCount = 0;
      }
      // Update shield timer if active
      if (player.shieldActive) {
        player.shieldTimer -= dt;
        if (player.shieldTimer <= 0) {
          player.shieldActive = false;
        }
      }
      // Animate player running (cycle frames every 100ms)
      player.animationTimer += dt;
      if (player.animationTimer > 100) {
        player.animationFrame = (player.animationFrame + 1) % 2;
        player.animationTimer = 0;
      }

      // Spawn obstacles, coins, and power-ups at intervals
      obstacleTimer += dt;
      if (obstacleTimer > obstacleInterval + Math.random() * 500) {
        spawnObstacle();
        obstacleTimer = 0;
      }
      coinTimer += dt;
      if (coinTimer > coinInterval + Math.random() * 800) {
        spawnCoin();
        coinTimer = 0;
      }
      powerTimer += dt;
      if (powerTimer > powerInterval + Math.random() * 2000) {
        spawnPowerUp();
        powerTimer = 0;
      }

      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].x -= gameSpeed * (obstacles[i].speedModifier || 1);
        // Remove offscreen obstacles
        if (obstacles[i].x + (obstacles[i].width || obstacles[i].radius*2) < 0)
          obstacles.splice(i, 1);
        else {
          // Collision detection with player (if not shielded)
          let obs = obstacles[i];
          let collision = false;
          if (obs.type === "boulder") {
            // Treat as circle collision
            collision = circleRectIntersect({x: obs.x+obs.radius, y: obs.y+obs.radius, radius: obs.radius}, player);
          } else {
            collision = rectIntersect(player, {x: obs.x, y: obs.y, width: obs.width, height: obs.height});
          }
          if (collision && !player.shieldActive) {
            playCollisionSound();
            endGame();
            return;
          }
        }
      }
      // Update coins
      for (let i = coins.length - 1; i >= 0; i--) {
        coins[i].x -= gameSpeed;
        if (coins[i].x + coins[i].radius < 0) {
          coins.splice(i, 1);
        } else {
          // Check collision with player (circle vs rectangle)
          if (circleRectIntersect({x: coins[i].x, y: coins[i].y, radius: coins[i].radius}, player)) {
            coinsCollected++;
            score += 10;
            playCoinSound();
            coins.splice(i, 1);
          }
        }
      }
      // Update power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        powerUps[i].x -= gameSpeed;
        if (powerUps[i].x + powerUps[i].size < 0) {
          powerUps.splice(i, 1);
        } else {
          if (rectIntersect(player, {x: powerUps[i].x, y: powerUps[i].y, width: powerUps[i].size, height: powerUps[i].size})) {
            // Auto-activate shield on pickup
            player.shieldActive = true;
            player.shieldTimer = player.shieldDuration;
            playPowerSound();
            powerUps.splice(i, 1);
          }
        }
      }
      // Update score over time
      score += dt * 0.01;
    }

    // ==========================
    // Drawing Functions
    // ==========================
    function drawBackground() {
      // Draw gradient background based on theme
      let grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, theme.gradient[0]);
      grad.addColorStop(1, theme.gradient[1]);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);
      // Draw far parallax objects (e.g., stars for night, clouds for day/sunset)
      farObjects.forEach(obj => {
        if (theme.extras === "stars") {
          ctx.fillStyle = "#fff";
          ctx.beginPath();
          ctx.arc(obj.x, obj.y, 2, 0, Math.PI*2);
          ctx.fill();
        } else {
          ctx.fillStyle = "rgba(255,255,255,0.8)";
          ctx.beginPath();
          ctx.arc(obj.x, obj.y, obj.size/10, 0, Math.PI*2);
          ctx.fill();
        }
      });
      // Draw near parallax objects (e.g., hills or trees)
      nearObjects.forEach(obj => {
        ctx.fillStyle = "#2d572c";
        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
      });
      // Draw ground
      ctx.fillStyle = "#654321";
      ctx.fillRect(0, groundY, width, groundHeight);
    }
    function drawPlayer() {
      // Draw a simple pixel-style character with basic running animation.
      // Body
      ctx.fillStyle = "#FFD700";
      ctx.fillRect(player.x, player.y, player.width, player.height);
      // Head (circle)
      ctx.beginPath();
      ctx.arc(player.x + player.width/2, player.y - 10, 10, 0, Math.PI*2);
      ctx.fillStyle = "#FFD700";
      ctx.fill();
      // Legs animation: alternate positions based on animationFrame
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.beginPath();
      if (player.animationFrame === 0) {
        // Left leg forward, right leg back
        ctx.moveTo(player.x + 10, player.y + player.height);
        ctx.lineTo(player.x + 10, player.y + player.height + 15);
        ctx.moveTo(player.x + 30, player.y + player.height);
        ctx.lineTo(player.x + 30, player.y + player.height + 5);
      } else {
        // Reverse
        ctx.moveTo(player.x + 10, player.y + player.height);
        ctx.lineTo(player.x + 10, player.y + player.height + 5);
        ctx.moveTo(player.x + 30, player.y + player.height);
        ctx.lineTo(player.x + 30, player.y + player.height + 15);
      }
      ctx.stroke();
      // Draw shield if active
      if (player.shieldActive) {
        ctx.strokeStyle = "#00FFFF";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    function drawObstacles() {
      obstacles.forEach(obs => {
        if (obs.type === "spike") {
          // Draw triangle spikes
          ctx.fillStyle = "#FF0000";
          ctx.beginPath();
          ctx.moveTo(obs.x, obs.y + obs.height);
          ctx.lineTo(obs.x + obs.width/2, obs.y);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();
        } else if (obs.type === "boulder") {
          // Draw rolling boulder
          ctx.fillStyle = "#555";
          ctx.beginPath();
          ctx.arc(obs.x + obs.radius, obs.y + obs.radius, obs.radius, 0, Math.PI*2);
          ctx.fill();
        } else if (obs.type === "bird") {
          // Draw a simple bird shape (small triangle)
          ctx.fillStyle = "#000";
          ctx.beginPath();
          ctx.moveTo(obs.x, obs.y + obs.height/2);
          ctx.lineTo(obs.x + obs.width, obs.y);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();
        }
      });
    }
    function drawCoins() {
      coins.forEach(coin => {
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function drawPowerUps() {
      powerUps.forEach(power => {
        ctx.fillStyle = "#17a2b8";
        ctx.beginPath();
        ctx.arc(power.x + power.size/2, power.y + power.size/2, power.size/2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("S", power.x + power.size/2, power.y + power.size/2 + 5);
      });
    }
    function drawHUD() {
      // Draw score, coins, and time in the top corners (optional additional info)
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      ctx.fillText("Score: " + Math.floor(score), 10, 20);
      ctx.fillText("Coins: " + coinsCollected, 10, 40);
      let seconds = Math.floor(elapsedTime / 1000);
      ctx.fillText("Time: " + seconds + "s", width - 100, 20);
    }
    function draw() {
      // Clear canvas and redraw everything
      drawBackground();
      drawCoins();
      drawPowerUps();
      drawObstacles();
      drawPlayer();
      drawHUD();
    }

    // ==========================
    // End Game & Overlay Screen
    // ==========================
    function endGame() {
      gameOver = true;
      // Save high score if needed
      if (score > highScore) {
        highScore = Math.floor(score);
        localStorage.setItem("highScore", highScore);
      }
      // Show overlay with stats
      overlay.innerHTML = `
        <h1>Game Over</h1>
        <p>Score: ${Math.floor(score)}</p>
        <p>Coins: ${coinsCollected}</p>
        <p>Time Survived: ${Math.floor(elapsedTime/1000)}s</p>
        <p>High Score: ${highScore}</p>
        <button id="restartButton" style="padding:10px 20px; font-size:18px;">Try Again</button>
      `;
      overlay.style.display = "flex";
      document.getElementById("restartButton").addEventListener("click", () => {
        resetGame();
      });
    }

    // ==========================
    // Start Game Function
    // ==========================
    function startGame() {
      if (!gameStarted) {
        resetGame();
        // Show on-screen buttons on touch devices
        if ('ontouchstart' in window || navigator.maxTouchPoints) {
          jumpButton.style.display = "block";
          powerButton.style.display = "block";
        }
      }
    }
    // Start game on overlay click/tap
    overlay.addEventListener("click", startGame);

    // Adjust canvas on window resize
    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
